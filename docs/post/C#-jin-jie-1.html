<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/70639984?s=400&u=fd8cb63c8a4dca59fea2601dc2256dcb9ce86235&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# C#进阶

![C#进阶](https://raw.githubusercontent.com/aiqingo/aiqingo.github.io/refs/heads/main/image/C%23%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9.jpg)

数据结构是什么

```
数据结构 
            //数据结构
            //数据结构是计算机存储、组织数据的方式（规则）
            //数据结构是指相互之间存在一种或多种特定关系的数据元素的集合
            //比如自定义的一个 类 也可以称为一种数据结构 自己定义的数据组合规则

            //不要把数据结构想的太复杂
            //简单点理解，就是人定义的 存储数据 和 表示数据之间关系 的规则而已

            //常用的数据结构（前辈总结和制定的一些经典规则）
            //数组、栈、队列、链表、树、图、堆、散列表
```

```
线性表
            //线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列
            //比如数组、ArrayList、Stack、Queue、链表等等
```
1. ### ArrayList

   ```
   #region  ArrayList的本质
               //ArrayList是一个C#为我们封装好的类，
               //它的本质是一个object类型的数组，
               //ArrayList类帮助我们实现了很多方法，
               //比如数组的增删查改
               #endregion
   
               #region  申明
               //需要引用命名空间using System.Collections;
               ArrayList array = new ArrayList();
               #endregion
   
               #region  增删查改
   
               #region 增
               array.Add(1);
               array.Add('123');
               array.Add(true);
               array.Add(new object());
               array.Add(new Test());
               array.Add(1);
               array.Add(true);
   
               ArrayList array2 = new ArrayList();
               array2.Add(123);
               //范围增加（批量增加 把另一个list容器里面的内容加到后面）
               array.AddRange(array2);
   
               array.Insert(1, '12345676');
               Console.WriteLine(array[1]);
               #endregion
   
               #region 删
   
               //移除指定元素 从头找 找到删
               array.Remove(1);
               //移除指定位置的元素
               array.RemoveAt(2);
               //清空
               //array.Clear();
   
               #endregion
   
               #region 查
               //得到指定位置的元素
               Console.WriteLine(array[0]);
   
               //查看元素是否存在
               if( array.Contains('1234') )
               {
                   Console.WriteLine('存在123');
               }
   
               //正向查找元素位置
               //找到的返回值 是位置 找不到 返回值 是-1
               int index = array.IndexOf(true);
               Console.WriteLine(index);
   
               Console.WriteLine(array.IndexOf(false));
   
               //反向查找元素位置
               //返回时从头开始的索引数
               index = array.LastIndexOf(true);
               Console.WriteLine(index);
               #endregion
   
               #region 改
               Console.WriteLine(array[0]);
               array[0] = '999';
               Console.WriteLine(array[0]);
               #endregion
   
               #endregion
   
               #region 遍历
               //长度
               Console.WriteLine(array.Count);
               //容量
               //避免产生过多的垃圾
               Console.WriteLine(array.Capacity);
               Console.WriteLine('***********************');
               for (int i = 0; i < array.Count; i++)
               {
                   Console.WriteLine(array[i]);
               }
               Console.WriteLine('***********************');
               //迭代器遍历
               foreach (object item in array)
               {
                   Console.WriteLine(item);
               }
   
               #endregion
   
               #region  装箱拆箱
               //ArrayList本质上是一个可以自动扩容的object数组，
               //由于用万物之父来存储数据，自然存在装箱拆箱。">
<meta property="og:title" content="C#进阶1">
<meta property="og:description" content="# C#进阶

![C#进阶](https://raw.githubusercontent.com/aiqingo/aiqingo.github.io/refs/heads/main/image/C%23%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9.jpg)

数据结构是什么

```
数据结构 
            //数据结构
            //数据结构是计算机存储、组织数据的方式（规则）
            //数据结构是指相互之间存在一种或多种特定关系的数据元素的集合
            //比如自定义的一个 类 也可以称为一种数据结构 自己定义的数据组合规则

            //不要把数据结构想的太复杂
            //简单点理解，就是人定义的 存储数据 和 表示数据之间关系 的规则而已

            //常用的数据结构（前辈总结和制定的一些经典规则）
            //数组、栈、队列、链表、树、图、堆、散列表
```

```
线性表
            //线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列
            //比如数组、ArrayList、Stack、Queue、链表等等
```
1. ### ArrayList

   ```
   #region  ArrayList的本质
               //ArrayList是一个C#为我们封装好的类，
               //它的本质是一个object类型的数组，
               //ArrayList类帮助我们实现了很多方法，
               //比如数组的增删查改
               #endregion
   
               #region  申明
               //需要引用命名空间using System.Collections;
               ArrayList array = new ArrayList();
               #endregion
   
               #region  增删查改
   
               #region 增
               array.Add(1);
               array.Add('123');
               array.Add(true);
               array.Add(new object());
               array.Add(new Test());
               array.Add(1);
               array.Add(true);
   
               ArrayList array2 = new ArrayList();
               array2.Add(123);
               //范围增加（批量增加 把另一个list容器里面的内容加到后面）
               array.AddRange(array2);
   
               array.Insert(1, '12345676');
               Console.WriteLine(array[1]);
               #endregion
   
               #region 删
   
               //移除指定元素 从头找 找到删
               array.Remove(1);
               //移除指定位置的元素
               array.RemoveAt(2);
               //清空
               //array.Clear();
   
               #endregion
   
               #region 查
               //得到指定位置的元素
               Console.WriteLine(array[0]);
   
               //查看元素是否存在
               if( array.Contains('1234') )
               {
                   Console.WriteLine('存在123');
               }
   
               //正向查找元素位置
               //找到的返回值 是位置 找不到 返回值 是-1
               int index = array.IndexOf(true);
               Console.WriteLine(index);
   
               Console.WriteLine(array.IndexOf(false));
   
               //反向查找元素位置
               //返回时从头开始的索引数
               index = array.LastIndexOf(true);
               Console.WriteLine(index);
               #endregion
   
               #region 改
               Console.WriteLine(array[0]);
               array[0] = '999';
               Console.WriteLine(array[0]);
               #endregion
   
               #endregion
   
               #region 遍历
               //长度
               Console.WriteLine(array.Count);
               //容量
               //避免产生过多的垃圾
               Console.WriteLine(array.Capacity);
               Console.WriteLine('***********************');
               for (int i = 0; i < array.Count; i++)
               {
                   Console.WriteLine(array[i]);
               }
               Console.WriteLine('***********************');
               //迭代器遍历
               foreach (object item in array)
               {
                   Console.WriteLine(item);
               }
   
               #endregion
   
               #region  装箱拆箱
               //ArrayList本质上是一个可以自动扩容的object数组，
               //由于用万物之父来存储数据，自然存在装箱拆箱。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://aiqingo.github.io/post/C%23-jin-jie-1.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/70639984?s=400&u=fd8cb63c8a4dca59fea2601dc2256dcb9ce86235&v=4">
<title>C#进阶1</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">C#进阶1</h1>
<div class="title-right">
    <a href="https://aiqingo.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/aiqingo/aiqingo.github.io/issues/5" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>C#进阶</h1>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/aiqingo/aiqingo.github.io/refs/heads/main/image/C%23%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9.jpg"><img src="https://raw.githubusercontent.com/aiqingo/aiqingo.github.io/refs/heads/main/image/C%23%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9.jpg" alt="C#进阶" style="max-width: 100%;"></a></p>
<p>数据结构是什么</p>
<pre class="notranslate"><code class="notranslate">数据结构 
            //数据结构
            //数据结构是计算机存储、组织数据的方式（规则）
            //数据结构是指相互之间存在一种或多种特定关系的数据元素的集合
            //比如自定义的一个 类 也可以称为一种数据结构 自己定义的数据组合规则

            //不要把数据结构想的太复杂
            //简单点理解，就是人定义的 存储数据 和 表示数据之间关系 的规则而已

            //常用的数据结构（前辈总结和制定的一些经典规则）
            //数组、栈、队列、链表、树、图、堆、散列表
</code></pre>
<pre class="notranslate"><code class="notranslate">线性表
            //线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列
            //比如数组、ArrayList、Stack、Queue、链表等等
</code></pre>
<ol>
<li>
<h3>ArrayList</h3>
<pre class="notranslate"><code class="notranslate">#region  ArrayList的本质
            //ArrayList是一个C#为我们封装好的类，
            //它的本质是一个object类型的数组，
            //ArrayList类帮助我们实现了很多方法，
            //比如数组的增删查改
            #endregion

            #region  申明
            //需要引用命名空间using System.Collections;
            ArrayList array = new ArrayList();
            #endregion

            #region  增删查改

            #region 增
            array.Add(1);
            array.Add("123");
            array.Add(true);
            array.Add(new object());
            array.Add(new Test());
            array.Add(1);
            array.Add(true);

            ArrayList array2 = new ArrayList();
            array2.Add(123);
            //范围增加（批量增加 把另一个list容器里面的内容加到后面）
            array.AddRange(array2);

            array.Insert(1, "12345676");
            Console.WriteLine(array[1]);
            #endregion

            #region 删

            //移除指定元素 从头找 找到删
            array.Remove(1);
            //移除指定位置的元素
            array.RemoveAt(2);
            //清空
            //array.Clear();

            #endregion

            #region 查
            //得到指定位置的元素
            Console.WriteLine(array[0]);

            //查看元素是否存在
            if( array.Contains("1234") )
            {
                Console.WriteLine("存在123");
            }

            //正向查找元素位置
            //找到的返回值 是位置 找不到 返回值 是-1
            int index = array.IndexOf(true);
            Console.WriteLine(index);

            Console.WriteLine(array.IndexOf(false));

            //反向查找元素位置
            //返回时从头开始的索引数
            index = array.LastIndexOf(true);
            Console.WriteLine(index);
            #endregion

            #region 改
            Console.WriteLine(array[0]);
            array[0] = "999";
            Console.WriteLine(array[0]);
            #endregion

            #endregion

            #region 遍历
            //长度
            Console.WriteLine(array.Count);
            //容量
            //避免产生过多的垃圾
            Console.WriteLine(array.Capacity);
            Console.WriteLine("***********************");
            for (int i = 0; i &lt; array.Count; i++)
            {
                Console.WriteLine(array[i]);
            }
            Console.WriteLine("***********************");
            //迭代器遍历
            foreach (object item in array)
            {
                Console.WriteLine(item);
            }

            #endregion

            #region  装箱拆箱
            //ArrayList本质上是一个可以自动扩容的object数组，
            //由于用万物之父来存储数据，自然存在装箱拆箱。
            //当往其中进行值类型存储时就是在装箱，当将值类型对象取出来转换使用时，就存在拆箱。
            //所以ArrayList尽量少用，之后我们会学习更好的数据容器。

            int k = 1;
            array[0] = k;//装箱
            k = (int)array[0];//拆箱
            #endregion
</code></pre>
</li>
<li>
<h3>Stack 栈</h3>
<pre class="notranslate"><code class="notranslate">      #region Stack的本质
            //Stack（栈）是一个C#为我们封装好的类
            //它的本质也是object[]数组，只是封装了特殊的存储规则

            //Stack是栈存储容器，栈是一种先进后出的数据结构
            //先存入的数据后获取，后存入的数据先获取
            //栈是先进后出
            #endregion

            #region  申明
            //需要引用命名空间 System.Collections
            Stack stack = new Stack();
            #endregion

            #region  增取查改

            #region 增
            //压栈
            stack.Push(1);
            stack.Push("123");
            stack.Push(true);
            stack.Push(1.2f);
            stack.Push(new Test());

            #endregion

            #region 取
            //栈中不存在删除的概念
            //只有取的概念
            //弹栈
            object v = stack.Pop();
            Console.WriteLine(v);

            v = stack.Pop();
            Console.WriteLine(v);
            #endregion

            #region 查
            //1.栈无法查看指定位置的 元素
            //  只能查看栈顶的内容
            v = stack.Peek();
            Console.WriteLine(v);
            v = stack.Peek();
            Console.WriteLine(v);

            //2.查看元素是否存在于栈中
            if( stack.Contains("123") )
            {
                Console.WriteLine("存在123");
            }

            #endregion

            #region 改
            //栈无法改变其中的元素 只能压(存)和弹（取）
            //实在要改 只有清空
            stack.Clear();
            Console.WriteLine(stack.Count);
            stack.Push("1");
            stack.Push(2);
            stack.Push("哈哈哈");
            #endregion

            #endregion

            #region   遍历
            //1.长度
            Console.WriteLine(stack.Count);

            //2.用foreach遍历
            //  而且遍历出来的顺序 也是从栈顶到栈底
            foreach(object item in stack)
            {
                Console.WriteLine(item);
            }

            //3.还有一种遍历方式
            //  将栈转换为object数组
            //  遍历出来的顺序 也是从栈顶到栈底
            object[] array = stack.ToArray();
            for (int i = 0; i &lt; array.Length; i++)
            {
                Console.WriteLine(array[i]);
            }

            Console.WriteLine(stack.Count);
            //4.循环弹栈
            while( stack.Count &gt; 0 )
            {
                object o = stack.Pop();
                Console.WriteLine(o);
            }
            Console.WriteLine(stack.Count);
            #endregion

            #region   装箱拆箱
            //由于用万物之父来存储数据，自然存在装箱拆箱。
            //当往其中进行值类型存储时就是在装箱
            //当将值类型对象取出来转换使用时，就存在拆箱。
            #endregion
            
            
            泛型栈
            Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
</code></pre>
</li>
<li>
<h3>Queue 队列</h3>
<pre class="notranslate"><code class="notranslate">  #region   申明
            //需要引用命名空间 System.Collections
            Queue queue = new Queue();
            #endregion

            #region   增取查改

            #region 增
            queue.Enqueue(1);
            queue.Enqueue("123");
            queue.Enqueue(1.4f);
            queue.Enqueue(new Test());
            #endregion

            #region 取
            //队列中不存在删除的概念
            //只有取的概念 取出先加入的对象
            object v = queue.Dequeue();
            Console.WriteLine(v);
            v = queue.Dequeue();
            Console.WriteLine(v);
            #endregion

            #region 查
            //1.查看队列头部元素但不会移除
            v = queue.Peek();
            Console.WriteLine(v);
            v = queue.Peek();
            Console.WriteLine(v);

            //2.查看元素是否存在于队列中
            if( queue.Contains(1.4f) )
            {
                Console.WriteLine("队列中存在1.4f");
            }

            #endregion

            #region 改
            //队列无法改变其中的元素 只能进出队列
            //实在要改 只有清
            Console.WriteLine(queue.Count);
            queue.Clear();
            queue.Enqueue(1);
            queue.Enqueue(2);
            queue.Enqueue(3);
            #endregion

            #endregion

            #region   遍历
            //1.长度
            Console.WriteLine(queue.Count);
            //2.用foreach遍历
            foreach (object item in queue)
            {
                Console.WriteLine(item);
            }
            //3.还有一种遍历方式
            //  将队列转换为object数组
            object[] array = queue.ToArray();
            for (int i = 0; i &lt; array.Length; i++)
            {
                Console.WriteLine(array[i]);
            }

            //4.循环出列
            while(queue.Count&gt;0)
            {
                object o = queue.Dequeue();
                Console.WriteLine(o);
            }
            Console.WriteLine(queue.Count);
            #endregion

            #region   装箱拆箱
            //由于用万物之父来存储数据，自然存在装箱拆箱。
            //当往其中进行值类型存储时就是在装箱
            //当将值类型对象取出来转换使用时，就存在拆箱。
            #endregion
            
            泛型队列
            Queue&lt;object&gt; queue = new Queue&lt;object&gt;();
</code></pre>
</li>
<li>
<h3>Hashtable</h3>
<pre class="notranslate"><code class="notranslate">  #region   Hashtalbe的本质
            //Hashtable（又称散列表） 是基于键的哈希代码组织起来的 键/值对
            //它的主要作用是提高数据查询的效率
            //使用键来访问集合中的元素
            #endregion

            #region   申明
            //需要引用命名空间 System.Collections
            Hashtable hashtable = new Hashtable();
            #endregion

            #region  增删查改

            #region 增
            hashtable.Add(1, "123");
            hashtable.Add("123", 2);
            hashtable.Add(true, false);
            hashtable.Add(false, false);
            //注意：不能出现相同键
            #endregion

            #region 删
            //1.只能通过键去删除
            hashtable.Remove(1);
            //2.删除不存在的键 没反应
            hashtable.Remove(2);

            //3.或者直接清空
            hashtable.Clear();
            hashtable.Add(1, "123");
            hashtable.Add(2, "1234");
            hashtable.Add(3, "123");
            hashtable.Add("123123", 12);
            #endregion

            #region 查
            //1.通过键查看值
            //  找不到会返回空
            Console.WriteLine(hashtable[1]);
            Console.WriteLine(hashtable[4]);//null
            Console.WriteLine(hashtable["123123"]);

            //2.查看是否存在
            //根据键检测
            if( hashtable.Contains(2) )
            {
                Console.WriteLine("存在键为2的键值对");
            }
            if( hashtable.ContainsKey(2) )
            {
                Console.WriteLine("存在键为2的键值对");
            }

            //根据值检测
            if( hashtable.ContainsValue(12) )
            {
                Console.WriteLine("存在值为12的键值对");
            }
            #endregion

            #region 改
            //只能改 键对应的值内容 无法修改键
            Console.WriteLine(hashtable[1]);
            hashtable[1] = 100.5f;
            Console.WriteLine(hashtable[1]);
            #endregion

            #endregion

            #region   遍历
            //得到键值对 对数
            Console.WriteLine(hashtable.Count);

            //1.遍历所有键
            foreach (object item in hashtable.Keys)
            {
                Console.WriteLine("键："+item);
                Console.WriteLine("值："+hashtable[item]);
            }

            //2.遍历所有值
            foreach (object item in hashtable.Values)
            {
                Console.WriteLine("值：" + item);
            }

            //3.键值对一起遍历
            foreach (DictionaryEntry item in hashtable)
            {
                Console.WriteLine("键：" + item.Key + "值：" + item.Value);
            }

            //4.迭代器遍历法
            IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
            bool flag = myEnumerator.MoveNext();
            while (flag)
            {
                Console.WriteLine("键：" + myEnumerator.Key + "值：" + myEnumerator.Value);
                flag = myEnumerator.MoveNext();
            }
            #endregion

            #region   装箱拆箱
            //由于用万物之父来存储数据，自然存在装箱拆箱
            //当往其中进行值类型存储时就是在装箱
            //当将值类型对象取出来转换使用时，就存在拆箱
            #endregion
</code></pre>
</li>
<li>
<h3>泛型</h3>
<pre class="notranslate"><code class="notranslate"> #region   泛型是什么
    //泛型实现了类型参数化，达到代码重用目的
    //通过类型参数化来实现同一份代码上操作多种类型

    //泛型相当于类型占位符
    //定义类或方法时使用替代符代表变量类型
    //当真正使用类或者方法时再具体指定类型
    #endregion

    #region   泛型分类
    //泛型类和泛型接口
    //基本语法：
    //class 类名&lt;泛型占位字母&gt;
    //interface 接口名&lt;泛型占位字母&gt;

    //泛型函数
    //基本语法：函数名&lt;泛型占位字母&gt;(参数列表)

    //注意：泛型占位字母可以有多个，用逗号分开
    #endregion

    #region   泛型类和接口

    class TestClass&lt;T&gt;
    {
        public T value;
    }    

    class TestClass2&lt;T1,T2,K,M,LL,Key,Value&gt;
    {
        public T1 value1;
        public T2 value2;
        public K value3;
        public M value4;
        public LL value5;
        public Key value6;
        public Value value7;
    }

    interface TestInterface&lt;T&gt;
    {
        T Value
        {
            get;
            set;
        }
    }

    class Test : TestInterface&lt;int&gt;
    {
        public int Value { get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); }
    }

    #endregion

    #region 泛型方法
    //1.普通类中的泛型方法

    class Test2
    {
        public void TestFun&lt;T&gt;( T value)
        {
            Console.WriteLine(value);
        }

        public void TestFun&lt;T&gt;()
        {
            //用泛型类型 在里面做一些逻辑处理
            T t = default(T);
        }

        public T TestFun&lt;T&gt;(string v)
        {
            return default(T);
        }

        public void TestFun&lt;T,K,M&gt;(T t, K k, M m)
        {

        }
    }

    //2.泛型类中的泛型方法
    class Test2&lt;T&gt;
    {
        public T value;

        public void TestFun&lt;K&gt;(K k)
        {
            Console.WriteLine(k);
        }

        //这个不叫泛型方法 因为 T是泛型类申明的时候 就指定 在使用这个函数的时候 
        //我们不能再去动态的变化了
        public void TestFun(T t)
        {

        }
    }

    #endregion

    #region   泛型的作用
    //1.不同类型对象的相同逻辑处理就可以选择泛型
    //2.使用泛型可以一定程度避免装箱拆箱
    //举例：优化ArrayList
    class ArrayList&lt;T&gt;
    {
        private T[] array;

        public void Add(T value)
        {

        }

        public void Remove( T value)
        {

        }
    }
    #endregion

    #region 总结
    //1.申明泛型时 它只是一个类型的占位符
    //2.泛型真正起作用的时候 是在使用它的时候
    //3.泛型占位字母可以有n个用逗号分开
    //4.泛型占位字母一般是大写字母
    //5.不确定泛型类型时 获取默认值 可以使用default(占位字符)
    //6.看到&lt;&gt;包裹的字母 那肯定是泛型
</code></pre>
</li>
<li>
<h3>泛型约束</h3>
<pre class="notranslate"><code class="notranslate"> #region   什么是泛型约束
    //让泛型的类型有一定的限制
    //关键字：where
    //泛型约束一共有6种
    //1.值类型                              where 泛型字母:struct
    //2.引用类型                            where 泛型字母:class
    //3.存在无参公共构造函数                 where 泛型字母:new()
    //4.某个类本身或者其派生类               where 泛型字母:类名
    //5.某个接口的派生类型                  where 泛型字母:接口名
    //6.另一个泛型类型本身或者派生类型       where 泛型字母:另一个泛型字母

    // where 泛型字母:(约束的类型)
    #endregion

    #region   各泛型约束讲解

    #region 值类型约束
    class Test1&lt;T&gt; where T:struct
    {
        public T value;
        public void TestFun&lt;K&gt;(K v) where K:struct
        {
        }
    }
    #endregion

    #region 引用类型约束
    class Test2&lt;T&gt; where T:class
    {
        public T value;

        public void TestFun&lt;K&gt;(K k) where K:class
        {
        }
    }
    #endregion

    #region 公共无参构造约束
    class Test3&lt;T&gt; where T:new()
    {
        public T value;

        public void TestFun&lt;K&gt;(K k) where K : new()
        {
        }
    }

    class Test1
    {
        public Test1()
        {
        }
    }

    class Test2
    {
        public Test2(int a)
        {
        }
    }
    #endregion

    #region 类约束
    class Test4&lt;T&gt; where T : Test1
    {
        public T value;

        public void TestFun&lt;K&gt;(K k) where K : Test1
        {
        }
    }

    class Test3:Test1
    {
    }
    #endregion

    #region 接口约束
    interface IFly
    {
    }

    interface IMove:IFly
    {
    }

    class Test4:IFly
    {
    }

    class Test5&lt;T&gt; where T : IFly
    {
        public T value;

        public void TestFun&lt;K&gt;(K k) where K : IFly
        {
        }
    }
    #endregion

    #region 另一个泛型约束
    class Test6&lt;T,U&gt; where T : U
    {
        public T value;

        public void TestFun&lt;K,V&gt;(K k) where K : V
        {
        }
    }
    #endregion

    #endregion

    #region   约束的组合使用
    class Test7&lt;T&gt; where T: class,new()
    {
    }
    #endregion

    #region   多个泛型有约束
    class Test8&lt;T,K&gt; where T:class,new() where K:struct
    {
    }
    #endregion

    #region 总结
    //泛型约束：让类型有一定限制
    //class
    //struct
    //new()
    //类名
    //接口名
    //另一个泛型字母

    //注意：
    //1.可以组合使用
    //2.多个泛型约束 用where连接即可
    #endregion
</code></pre>
</li>
<li>
<h3>List</h3>
<pre class="notranslate"><code class="notranslate"> #region  List的本质
            //List是一个C#为我们封装好的类，
            //它的本质是一个可变类型的泛型数组，
            //List类帮助我们实现了很多方法，
            //比如泛型数组的增删查改
            #endregion

            #region   申明
            //需要引用命名空间
            //using System.Collections.Generic
            List&lt;int&gt; list = new List&lt;int&gt;();
            List&lt;string&gt; list2 = new List&lt;string&gt;();
            List&lt;bool&gt; list3 = new List&lt;bool&gt;();
            #endregion

            #region 增删查改

            #region 增
            list.Add(1);
            list.Add(2);
            list.Add(3);
            list.Add(4);

            list2.Add("123");

            List&lt;string&gt; listStr = new List&lt;string&gt;();
            listStr.Add("123");
            list2.AddRange(listStr);

            list.Insert(0, 999);
            Console.WriteLine(list[0]);
            #endregion

            #region 删
            //1.移除指定元素
            list.Remove(1);
            //2.移除指定位置的元素
            list.RemoveAt(0);
            //3.清空
            list.Clear();

            list.Add(1);
            list.Add(2);
            list.Add(3);
            list.Add(4);
            list.Add(1);
            #endregion

            #region 查
            //1.得到指定位置的元素
            Console.WriteLine(list[0]);
            //2.查看元素是否存在
            if( list.Contains(1) )
            {
                Console.WriteLine("存在元素 1");
            }
            //3.正向查找元素位置
            // 找到返回位置 找不到 返回-1
            int index = list.IndexOf(5);
            Console.WriteLine(index);
            //4.反向查找元素位置
            // 找到返回位置 找不到 返回-1
            index = list.LastIndexOf(2);
            Console.WriteLine(index);
            #endregion

            #region 改
            Console.WriteLine(list[0]);
            list[0] = 99;
            Console.WriteLine(list[0]);
            #endregion

            #endregion

            #region  遍历
            //长度
            Console.WriteLine(list.Count);
            //容量
            //避免产生垃圾
            Console.WriteLine(list.Capacity);
            Console.WriteLine("**********************");
            for (int i = 0; i &lt; list.Count; i++)
            {
                Console.WriteLine(list[i]);
            }
            Console.WriteLine("**********************");
            foreach (int item in list)
            {
                Console.WriteLine(item);
            }

            #endregion
</code></pre>
</li>
<li>
<h3>Dictionary</h3>
<pre class="notranslate"><code class="notranslate">#region Dictionary的本质
            //可以将Dictionary理解为 拥有泛型的Hashtable
            //它也是基于键的哈希代码组织起来的 键/值对
            //键值对类型从Hashtable的object变为了可以自己制定的泛型
            #endregion

            #region   申明
            //需要引用命名空间 using System.Collections.Generic
            Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();
            #endregion

            #region  增删查改

            #region 增
            //注意：不能出现相同键
            dictionary.Add(1, "123");
            dictionary.Add(2, "222");
            dictionary.Add(3, "222");
            //dictionary.Add(3, "123");
            #endregion

            #region 删
            //1.只能通过键去删除
            //  删除不存在键 没反应
            dictionary.Remove(1);
            dictionary.Remove(4);

            //2.清空
            dictionary.Clear();
            dictionary.Add(1, "123");
            dictionary.Add(2, "222");
            dictionary.Add(3, "222");
            #endregion

            #region 查
            //1.通过键查看值
            //  找不到直接报错
            Console.WriteLine(dictionary[2]);
            //Console.WriteLine(dictionary[4]);
            Console.WriteLine(dictionary[1]);

            //2.查看是否存在
            //  根据键检测
            if( dictionary.ContainsKey(4) )
            {
                Console.WriteLine("存在键为1的键值对");
            }
            //  根据值检测
            if (dictionary.ContainsValue("1234"))
            {
                Console.WriteLine("存在值为123的键值对");
            }

            #endregion

            #region 改
            Console.WriteLine(dictionary[1]);
            dictionary[1] = "555";
            Console.WriteLine(dictionary[1]);
            #endregion

            #endregion

            #region   遍历
            Console.WriteLine("**************");
            Console.WriteLine(dictionary.Count);
            //1.遍历所有键
            foreach (int item in dictionary.Keys)
            {
                Console.WriteLine(item);
                Console.WriteLine(dictionary[item]);
            }
            //2.遍历所有值
            Console.WriteLine("**************");
            foreach (string item in dictionary.Values)
            {
                Console.WriteLine(item);
            }
            //3.键值对一起遍历
            Console.WriteLine("**************");
            foreach (KeyValuePair&lt;int,string&gt; item in dictionary)
            {
                Console.WriteLine("键：" + item.Key + "值：" + item.Value);
            }
            #endregion
</code></pre>
</li>
<li>
<h3>顺序存储 和 链式存储</h3>
<pre class="notranslate"><code class="notranslate"> #region 顺序存储
            //数组、Stack、Queue、List、ArrayList —— 顺序存储
            //只是 数组、Stack、Queue的 组织规则不同而已
            //顺序存储：
            //用一组地址连续的存储单元依次存储线性表的各个数据元素
            #endregion

            #region 链式存储
            //单向链表、双向链表、循环链表 —— 链式存储
            //链式存储(链接存储)：
            //用一组任意的存储单元存储线性表中的各个数据元素
            #endregion
            
                #region   实现一个最简单的单向链表
    /// &lt;summary&gt;
    /// 单向链表节点
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    class LinkedNode&lt;T&gt;
    {
        public T value;
        //这个存储下一个元素是谁 相当于钩子
        public LinkedNode&lt;T&gt; nextNode;

        public LinkedNode(T value)
        {
            this.value = value;
        }
    }

    /// &lt;summary&gt;
    /// 单向链表类 管理 节点 管理 添加等等
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    class LindedList&lt;T&gt;
    {
        public LinkedNode&lt;T&gt; head;
        public LinkedNode&lt;T&gt; last;

        public void Add(T value)
        {
            //添加节点 必然是new一个新的节点
            LinkedNode&lt;T&gt; node = new LinkedNode&lt;T&gt;(value);
            if( head == null )
            {
                head = node;
                last = node;
            }
            else
            {
                last.nextNode = node;
                last = node;
            }
        }

        public void Remove(T value)
        {
            if( head == null )
            {
                return;
            }
            if( head.value.Equals(value) )
            {
                head = head.nextNode;
                //如果头节点 被移除 发现头节点变空
                //证明只有一个节点 那尾也要清空
                if( head == null )
                {
                    last = null;
                }
                return;
            }
            LinkedNode&lt;T&gt; node = head;
            while(node.nextNode != null)
            {
                if( node.nextNode.value.Equals(value) )
                {
                    //让当前找到的这个元素的 上一个节点
                    //指向 自己的下一个节点
                    node.nextNode = node.nextNode.nextNode;
                    break;
                }
            }
        }
    }
    #endregion

    #region   顺序存储和链式存储的优缺点
    //从增删查改的角度去思考
    //增：链式存储 计算上 优于顺序存储 （中间插入时链式不用像顺序一样去移动位置）
    //删：链式存储 计算上 优于顺序存储 （中间删除时链式不用像顺序一样去移动位置）
    //查：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）
    //改：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）
    #endregion
</code></pre>
</li>
<li>
<h3>LinkedList</h3>
<pre class="notranslate"><code class="notranslate">  #region   LinkedList
            //LinkedList是一个C#为我们封装好的类
            //它的本质是一个可变类型的泛型双向链表
            #endregion

            #region   申明
            //需要引用命名空间
            //using System.Collections.Generic
            LinkedList&lt;int&gt; linkedList = new LinkedList&lt;int&gt;();
            LinkedList&lt;string&gt; linkedList2 = new LinkedList&lt;string&gt;();
            //链表对象 需要掌握两个类
            //一个是链表本身 一个是链表节点类LinkedListNode
            #endregion

            #region  增删查改

            #region 增
            //1.在链表尾部添加元素
            linkedList.AddLast(10);

            //2.在链表头部添加元素
            linkedList.AddFirst(20);

            //3.在某一个节点之后添加一个节点
            //  要指定节点 先得得到一个节点
            LinkedListNode&lt;int&gt; n = linkedList.Find(20);
            linkedList.AddAfter(n, 15);
            //4.在某一个节点之前添加一个节点
            //  要指定节点 先得得到一个节点
            linkedList.AddBefore(n, 11);
            #endregion

            #region 删
            //1.移除头节点
            linkedList.RemoveFirst();
            //2.移除尾节点
            linkedList.RemoveLast();
            //3.移除指定节点
            //  无法通过位置直接移除
            linkedList.Remove(20);
            //4.清空
            linkedList.Clear();

            linkedList.AddLast(1);
            linkedList.AddLast(2);
            linkedList.AddLast(3);
            linkedList.AddLast(4);
            #endregion

            #region 查
            //1.头节点
            LinkedListNode&lt;int&gt; first = linkedList.First;
            //2.尾节点
            LinkedListNode&lt;int&gt; last = linkedList.Last;
            //3.找到指定值的节点
            //  无法直接通过下标获取中间元素
            //  只有遍历查找指定位置元素
            LinkedListNode&lt;int&gt; node = linkedList.Find(3);
            Console.WriteLine(node.Value);
            node = linkedList.Find(5);
            //4.判断是否存在
            if( linkedList.Contains(1) )
            {
                Console.WriteLine("链表中存在1");
            }
            #endregion

            #region 改
            //要先得再改 得到节点 再改变其中的值
            Console.WriteLine(linkedList.First.Value);
            linkedList.First.Value = 10;
            Console.WriteLine(linkedList.First.Value);
            #endregion

            #endregion

            #region   遍历
            //1.foreach遍历
            foreach (int item in linkedList)
            {
                Console.WriteLine(item);
            }

            //2.通过节点遍历
            //  从头到尾
            Console.WriteLine("&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;");
            LinkedListNode&lt;int&gt; nowNode = linkedList.First;
            while (nowNode != null)
            {
                Console.WriteLine(nowNode.Value);
                nowNode = nowNode.Next;
            }

            //  从尾到头

            Console.WriteLine("&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;");
            nowNode = linkedList.Last;
            while (nowNode != null)
            {
                Console.WriteLine(nowNode.Value);
                nowNode = nowNode.Previous;
            }

            #endregion
</code></pre>
</li>
<li>
<h3>泛型栈 和 队列</h3>
<pre class="notranslate"><code class="notranslate">   #region 泛型数据集合
            //using System.Collections.Generic;

            //List  列表  泛型列表
            //Dictionary 字典  泛型哈希表
            //LinkedList 双向链表 
            //Statck 泛型栈
            //Queue 泛型队列
            #endregion

            #endregion

            #region   泛型栈和队列
            //命名空间：using System.Collections.Generic;
            //使用上 和之前的Stack和Queue一模一样
            Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
            Queue&lt;object&gt; queue = new Queue&lt;object&gt;();
            #endregion
</code></pre>
</li>
<li>
<h3>委托</h3>
<pre class="notranslate"><code class="notranslate">using System;
namespace Lesson12_委托
{
    #region   委托是什么
    //委托是 函数(方法)的容器 
    //可以理解为表示函数(方法)的变量类型
    //用来 存储、传递函数(方法)
    //委托的本质是一个类，用来定义函数(方法)的类型（返回值和参数的类型）
    //不同的 函数(方法)必须对应和各自"格式"一致的委托
    #endregion
    #region   基本语法
    //关键字 ： delegate
    //语法：访问修饰符 delegate 返回值 委托名(参数列表);
    //写在哪里？
    //可以申明在namespace和class语句块中
    //更多的写在namespace中
    //简单记忆委托语法 就是 函数申明语法前面加一个delegate关键字
    #endregion
    #region   定义自定义委托
    //访问修饰默认不写 为public 在别的命名空间中也能使用
    //private 其它命名空间就不能用了
    //一般使用public
    //申明了一个可以用来存储无参无返回值函数的容器
    //这里只是定义了规则 并没有使用
    delegate void MyFun();
    //委托规则的申明 是不能重名（同一语句块中）
    //表示用来装载或传递 返回值为int 有一个int参数的函数的 委托 容器规则
    public delegate int MyFun2(int a);
    //委托是支持 泛型的 可以让返回值和参数 可变 更方便我们的使用
    delegate T MyFun3&lt;T, K&gt;(T v, K k);
    #endregion
    #region   使用定义好的委托
    //委托变量是函数的容器
    //委托常用在：
    //1.作为类的成员
    //2.作为函数的参数
    class Test
    {
        public MyFun fun;
        public MyFun2 fun2;
        public Action action;
        public void TestFun( MyFun fun, MyFun2 fun2 )
        {
            //先处理一些别的逻辑 当这些逻辑处理完了 再执行传入的函数
            int i = 1;
            i *= 2;
            i += 2;
            //fun();
            //fun2(i);
            //this.fun = fun;
            //this.fun2 = fun2;
        }
        #region 增 委托变量可以存储多个函数(多播委托)
        public void AddFun(MyFun fun, MyFun2 fun2)
        {
            this.fun += fun;
            this.fun2 += fun2;
        }
        #endregion
        #region 删
        public void RemoveFun(MyFun fun, MyFun2 fun2)
        {
            //this.fun = this.fun - fun;
            this.fun -= fun;
            this.fun2 -= fun2;
        }
        #endregion
    }
    #endregion
    ------------------
            Console.WriteLine("委托");
            //专门用来装载 函数的 容器
            MyFun f = new MyFun(Fun);
            Console.WriteLine("1");
            Console.WriteLine("2");
            Console.WriteLine("3");
            Console.WriteLine("4");
            Console.WriteLine("5");
            f.Invoke();

            MyFun f2 = Fun;
            f2();
            MyFun2 f3 = Fun2;
            Console.WriteLine(f3(1));
            MyFun2 f4 = new MyFun2(Fun2);
            Console.WriteLine(f4.Invoke(3));
            Test t = new Test();
            t.TestFun(Fun, Fun2);
            Console.WriteLine("***************");
            //如何用委托存储多个函数
            MyFun ff = null;
            //ff = ff + Fun;
            ff += Fun;
            ff += Fun3;
            ff();
            //从容器中移除指定的函数
            ff -= Fun;
            //多减 不会报错 无非就是不处理而已
            ff -= Fun;
            ff();
            //清空容器
            ff = null;
            if( ff != null )
            {
                ff();
            }
            #region 知识点六 系统定义好的委托
            //使用系统自带委托 需要引用using System;
            //无参无返回值
            Action action = Fun;
            action += Fun3;
            action();
            //可以指定返回值类型的 泛型委托
            Func&lt;string&gt; funcString = Fun4;
            Func&lt;int&gt; funcInt = Fun5;
            //可以传n个参数的  系统提供了 1到16个参数的委托 直接用就行了
            Action&lt;int, string&gt; action2 = Fun6;
            //可以穿n个参数的 并且有返回值的 系统也提供了 16个委托
            Func&lt;int, int&gt; func2 = Fun2;
            #endregion
        }

        static void Fun(){}
        static void Fun3(){}
        static string Fun4(){}
        static int Fun5(){}
        static void Fun6(int i, string s){}
		static int Fun2(int value){}
    }

    //总结
    //简单理解 委托 就是装载、传递函数的容器而已
    //可以用委托变量 来存储函数或者传递函数的
    //系统其实已经提供了很多委托给我们用 
    //Action:没有返回值，参数提供了 0~16个委托给我们用
    //Func:有返回值，参数提供了 0~16个委托给我们用
}

</code></pre>
</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://aiqingo.github.io">小王的博客</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","aiqingo/aiqingo.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
