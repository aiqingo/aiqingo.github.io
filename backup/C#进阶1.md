# C#进阶

![C#进阶](https://raw.githubusercontent.com/aiqingo/aiqingo.github.io/refs/heads/main/image/C%23%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9.jpg)

数据结构是什么

```
数据结构 
            //数据结构
            //数据结构是计算机存储、组织数据的方式（规则）
            //数据结构是指相互之间存在一种或多种特定关系的数据元素的集合
            //比如自定义的一个 类 也可以称为一种数据结构 自己定义的数据组合规则

            //不要把数据结构想的太复杂
            //简单点理解，就是人定义的 存储数据 和 表示数据之间关系 的规则而已

            //常用的数据结构（前辈总结和制定的一些经典规则）
            //数组、栈、队列、链表、树、图、堆、散列表
```

```
线性表
            //线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列
            //比如数组、ArrayList、Stack、Queue、链表等等
```
1. ### ArrayList

   ```
   #region  ArrayList的本质
               //ArrayList是一个C#为我们封装好的类，
               //它的本质是一个object类型的数组，
               //ArrayList类帮助我们实现了很多方法，
               //比如数组的增删查改
               #endregion
   
               #region  申明
               //需要引用命名空间using System.Collections;
               ArrayList array = new ArrayList();
               #endregion
   
               #region  增删查改
   
               #region 增
               array.Add(1);
               array.Add("123");
               array.Add(true);
               array.Add(new object());
               array.Add(new Test());
               array.Add(1);
               array.Add(true);
   
               ArrayList array2 = new ArrayList();
               array2.Add(123);
               //范围增加（批量增加 把另一个list容器里面的内容加到后面）
               array.AddRange(array2);
   
               array.Insert(1, "12345676");
               Console.WriteLine(array[1]);
               #endregion
   
               #region 删
   
               //移除指定元素 从头找 找到删
               array.Remove(1);
               //移除指定位置的元素
               array.RemoveAt(2);
               //清空
               //array.Clear();
   
               #endregion
   
               #region 查
               //得到指定位置的元素
               Console.WriteLine(array[0]);
   
               //查看元素是否存在
               if( array.Contains("1234") )
               {
                   Console.WriteLine("存在123");
               }
   
               //正向查找元素位置
               //找到的返回值 是位置 找不到 返回值 是-1
               int index = array.IndexOf(true);
               Console.WriteLine(index);
   
               Console.WriteLine(array.IndexOf(false));
   
               //反向查找元素位置
               //返回时从头开始的索引数
               index = array.LastIndexOf(true);
               Console.WriteLine(index);
               #endregion
   
               #region 改
               Console.WriteLine(array[0]);
               array[0] = "999";
               Console.WriteLine(array[0]);
               #endregion
   
               #endregion
   
               #region 遍历
               //长度
               Console.WriteLine(array.Count);
               //容量
               //避免产生过多的垃圾
               Console.WriteLine(array.Capacity);
               Console.WriteLine("***********************");
               for (int i = 0; i < array.Count; i++)
               {
                   Console.WriteLine(array[i]);
               }
               Console.WriteLine("***********************");
               //迭代器遍历
               foreach (object item in array)
               {
                   Console.WriteLine(item);
               }
   
               #endregion
   
               #region  装箱拆箱
               //ArrayList本质上是一个可以自动扩容的object数组，
               //由于用万物之父来存储数据，自然存在装箱拆箱。
               //当往其中进行值类型存储时就是在装箱，当将值类型对象取出来转换使用时，就存在拆箱。
               //所以ArrayList尽量少用，之后我们会学习更好的数据容器。
   
               int k = 1;
               array[0] = k;//装箱
               k = (int)array[0];//拆箱
               #endregion
   ```
2. ### Stack 栈

   ```
         #region Stack的本质
               //Stack（栈）是一个C#为我们封装好的类
               //它的本质也是object[]数组，只是封装了特殊的存储规则
   
               //Stack是栈存储容器，栈是一种先进后出的数据结构
               //先存入的数据后获取，后存入的数据先获取
               //栈是先进后出
               #endregion
   
               #region  申明
               //需要引用命名空间 System.Collections
               Stack stack = new Stack();
               #endregion
   
               #region  增取查改
   
               #region 增
               //压栈
               stack.Push(1);
               stack.Push("123");
               stack.Push(true);
               stack.Push(1.2f);
               stack.Push(new Test());
   
               #endregion
   
               #region 取
               //栈中不存在删除的概念
               //只有取的概念
               //弹栈
               object v = stack.Pop();
               Console.WriteLine(v);
   
               v = stack.Pop();
               Console.WriteLine(v);
               #endregion
   
               #region 查
               //1.栈无法查看指定位置的 元素
               //  只能查看栈顶的内容
               v = stack.Peek();
               Console.WriteLine(v);
               v = stack.Peek();
               Console.WriteLine(v);
   
               //2.查看元素是否存在于栈中
               if( stack.Contains("123") )
               {
                   Console.WriteLine("存在123");
               }
   
               #endregion
   
               #region 改
               //栈无法改变其中的元素 只能压(存)和弹（取）
               //实在要改 只有清空
               stack.Clear();
               Console.WriteLine(stack.Count);
               stack.Push("1");
               stack.Push(2);
               stack.Push("哈哈哈");
               #endregion
   
               #endregion
   
               #region   遍历
               //1.长度
               Console.WriteLine(stack.Count);
   
               //2.用foreach遍历
               //  而且遍历出来的顺序 也是从栈顶到栈底
               foreach(object item in stack)
               {
                   Console.WriteLine(item);
               }
   
               //3.还有一种遍历方式
               //  将栈转换为object数组
               //  遍历出来的顺序 也是从栈顶到栈底
               object[] array = stack.ToArray();
               for (int i = 0; i < array.Length; i++)
               {
                   Console.WriteLine(array[i]);
               }
   
               Console.WriteLine(stack.Count);
               //4.循环弹栈
               while( stack.Count > 0 )
               {
                   object o = stack.Pop();
                   Console.WriteLine(o);
               }
               Console.WriteLine(stack.Count);
               #endregion
   
               #region   装箱拆箱
               //由于用万物之父来存储数据，自然存在装箱拆箱。
               //当往其中进行值类型存储时就是在装箱
               //当将值类型对象取出来转换使用时，就存在拆箱。
               #endregion
               
               
               泛型栈
               Stack<int> stack = new Stack<int>();
   ```

3. ### Queue 队列

   ```
     #region   申明
               //需要引用命名空间 System.Collections
               Queue queue = new Queue();
               #endregion
   
               #region   增取查改
   
               #region 增
               queue.Enqueue(1);
               queue.Enqueue("123");
               queue.Enqueue(1.4f);
               queue.Enqueue(new Test());
               #endregion
   
               #region 取
               //队列中不存在删除的概念
               //只有取的概念 取出先加入的对象
               object v = queue.Dequeue();
               Console.WriteLine(v);
               v = queue.Dequeue();
               Console.WriteLine(v);
               #endregion
   
               #region 查
               //1.查看队列头部元素但不会移除
               v = queue.Peek();
               Console.WriteLine(v);
               v = queue.Peek();
               Console.WriteLine(v);
   
               //2.查看元素是否存在于队列中
               if( queue.Contains(1.4f) )
               {
                   Console.WriteLine("队列中存在1.4f");
               }
   
               #endregion
   
               #region 改
               //队列无法改变其中的元素 只能进出队列
               //实在要改 只有清
               Console.WriteLine(queue.Count);
               queue.Clear();
               queue.Enqueue(1);
               queue.Enqueue(2);
               queue.Enqueue(3);
               #endregion
   
               #endregion
   
               #region   遍历
               //1.长度
               Console.WriteLine(queue.Count);
               //2.用foreach遍历
               foreach (object item in queue)
               {
                   Console.WriteLine(item);
               }
               //3.还有一种遍历方式
               //  将队列转换为object数组
               object[] array = queue.ToArray();
               for (int i = 0; i < array.Length; i++)
               {
                   Console.WriteLine(array[i]);
               }
   
               //4.循环出列
               while(queue.Count>0)
               {
                   object o = queue.Dequeue();
                   Console.WriteLine(o);
               }
               Console.WriteLine(queue.Count);
               #endregion
   
               #region   装箱拆箱
               //由于用万物之父来存储数据，自然存在装箱拆箱。
               //当往其中进行值类型存储时就是在装箱
               //当将值类型对象取出来转换使用时，就存在拆箱。
               #endregion
               
               泛型队列
               Queue<object> queue = new Queue<object>();
   ```
4. ### Hashtable

   ```
     #region   Hashtalbe的本质
               //Hashtable（又称散列表） 是基于键的哈希代码组织起来的 键/值对
               //它的主要作用是提高数据查询的效率
               //使用键来访问集合中的元素
               #endregion
   
               #region   申明
               //需要引用命名空间 System.Collections
               Hashtable hashtable = new Hashtable();
               #endregion
   
               #region  增删查改
   
               #region 增
               hashtable.Add(1, "123");
               hashtable.Add("123", 2);
               hashtable.Add(true, false);
               hashtable.Add(false, false);
               //注意：不能出现相同键
               #endregion
   
               #region 删
               //1.只能通过键去删除
               hashtable.Remove(1);
               //2.删除不存在的键 没反应
               hashtable.Remove(2);
   
               //3.或者直接清空
               hashtable.Clear();
               hashtable.Add(1, "123");
               hashtable.Add(2, "1234");
               hashtable.Add(3, "123");
               hashtable.Add("123123", 12);
               #endregion
   
               #region 查
               //1.通过键查看值
               //  找不到会返回空
               Console.WriteLine(hashtable[1]);
               Console.WriteLine(hashtable[4]);//null
               Console.WriteLine(hashtable["123123"]);
   
               //2.查看是否存在
               //根据键检测
               if( hashtable.Contains(2) )
               {
                   Console.WriteLine("存在键为2的键值对");
               }
               if( hashtable.ContainsKey(2) )
               {
                   Console.WriteLine("存在键为2的键值对");
               }
   
               //根据值检测
               if( hashtable.ContainsValue(12) )
               {
                   Console.WriteLine("存在值为12的键值对");
               }
               #endregion
   
               #region 改
               //只能改 键对应的值内容 无法修改键
               Console.WriteLine(hashtable[1]);
               hashtable[1] = 100.5f;
               Console.WriteLine(hashtable[1]);
               #endregion
   
               #endregion
   
               #region   遍历
               //得到键值对 对数
               Console.WriteLine(hashtable.Count);
   
               //1.遍历所有键
               foreach (object item in hashtable.Keys)
               {
                   Console.WriteLine("键："+item);
                   Console.WriteLine("值："+hashtable[item]);
               }
   
               //2.遍历所有值
               foreach (object item in hashtable.Values)
               {
                   Console.WriteLine("值：" + item);
               }
   
               //3.键值对一起遍历
               foreach (DictionaryEntry item in hashtable)
               {
                   Console.WriteLine("键：" + item.Key + "值：" + item.Value);
               }
   
               //4.迭代器遍历法
               IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
               bool flag = myEnumerator.MoveNext();
               while (flag)
               {
                   Console.WriteLine("键：" + myEnumerator.Key + "值：" + myEnumerator.Value);
                   flag = myEnumerator.MoveNext();
               }
               #endregion
   
               #region   装箱拆箱
               //由于用万物之父来存储数据，自然存在装箱拆箱
               //当往其中进行值类型存储时就是在装箱
               //当将值类型对象取出来转换使用时，就存在拆箱
               #endregion
   ```
5. ### 泛型

   ```
    #region   泛型是什么
       //泛型实现了类型参数化，达到代码重用目的
       //通过类型参数化来实现同一份代码上操作多种类型
   
       //泛型相当于类型占位符
       //定义类或方法时使用替代符代表变量类型
       //当真正使用类或者方法时再具体指定类型
       #endregion
   
       #region   泛型分类
       //泛型类和泛型接口
       //基本语法：
       //class 类名<泛型占位字母>
       //interface 接口名<泛型占位字母>
   
       //泛型函数
       //基本语法：函数名<泛型占位字母>(参数列表)
   
       //注意：泛型占位字母可以有多个，用逗号分开
       #endregion
   
       #region   泛型类和接口
   
       class TestClass<T>
       {
           public T value;
       }    
   
       class TestClass2<T1,T2,K,M,LL,Key,Value>
       {
           public T1 value1;
           public T2 value2;
           public K value3;
           public M value4;
           public LL value5;
           public Key value6;
           public Value value7;
       }
   
       interface TestInterface<T>
       {
           T Value
           {
               get;
               set;
           }
       }
   
       class Test : TestInterface<int>
       {
           public int Value { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
       }
   
       #endregion
   
       #region 泛型方法
       //1.普通类中的泛型方法
   
       class Test2
       {
           public void TestFun<T>( T value)
           {
               Console.WriteLine(value);
           }
   
           public void TestFun<T>()
           {
               //用泛型类型 在里面做一些逻辑处理
               T t = default(T);
           }
   
           public T TestFun<T>(string v)
           {
               return default(T);
           }
   
           public void TestFun<T,K,M>(T t, K k, M m)
           {
   
           }
       }
   
       //2.泛型类中的泛型方法
       class Test2<T>
       {
           public T value;
   
           public void TestFun<K>(K k)
           {
               Console.WriteLine(k);
           }
   
           //这个不叫泛型方法 因为 T是泛型类申明的时候 就指定 在使用这个函数的时候 
           //我们不能再去动态的变化了
           public void TestFun(T t)
           {
   
           }
       }
   
       #endregion
   
       #region   泛型的作用
       //1.不同类型对象的相同逻辑处理就可以选择泛型
       //2.使用泛型可以一定程度避免装箱拆箱
       //举例：优化ArrayList
       class ArrayList<T>
       {
           private T[] array;
   
           public void Add(T value)
           {
   
           }
   
           public void Remove( T value)
           {
   
           }
       }
       #endregion
   
       #region 总结
       //1.申明泛型时 它只是一个类型的占位符
       //2.泛型真正起作用的时候 是在使用它的时候
       //3.泛型占位字母可以有n个用逗号分开
       //4.泛型占位字母一般是大写字母
       //5.不确定泛型类型时 获取默认值 可以使用default(占位字符)
       //6.看到<>包裹的字母 那肯定是泛型
   ```
6. ### 泛型约束

   ```
    #region   什么是泛型约束
       //让泛型的类型有一定的限制
       //关键字：where
       //泛型约束一共有6种
       //1.值类型                              where 泛型字母:struct
       //2.引用类型                            where 泛型字母:class
       //3.存在无参公共构造函数                 where 泛型字母:new()
       //4.某个类本身或者其派生类               where 泛型字母:类名
       //5.某个接口的派生类型                  where 泛型字母:接口名
       //6.另一个泛型类型本身或者派生类型       where 泛型字母:另一个泛型字母
   
       // where 泛型字母:(约束的类型)
       #endregion
   
       #region   各泛型约束讲解
   
       #region 值类型约束
       class Test1<T> where T:struct
       {
           public T value;
           public void TestFun<K>(K v) where K:struct
           {
           }
       }
       #endregion
   
       #region 引用类型约束
       class Test2<T> where T:class
       {
           public T value;
   
           public void TestFun<K>(K k) where K:class
           {
           }
       }
       #endregion
   
       #region 公共无参构造约束
       class Test3<T> where T:new()
       {
           public T value;
   
           public void TestFun<K>(K k) where K : new()
           {
           }
       }
   
       class Test1
       {
           public Test1()
           {
           }
       }
   
       class Test2
       {
           public Test2(int a)
           {
           }
       }
       #endregion
   
       #region 类约束
       class Test4<T> where T : Test1
       {
           public T value;
   
           public void TestFun<K>(K k) where K : Test1
           {
           }
       }
   
       class Test3:Test1
       {
       }
       #endregion
   
       #region 接口约束
       interface IFly
       {
       }
   
       interface IMove:IFly
       {
       }
   
       class Test4:IFly
       {
       }
   
       class Test5<T> where T : IFly
       {
           public T value;
   
           public void TestFun<K>(K k) where K : IFly
           {
           }
       }
       #endregion
   
       #region 另一个泛型约束
       class Test6<T,U> where T : U
       {
           public T value;
   
           public void TestFun<K,V>(K k) where K : V
           {
           }
       }
       #endregion
   
       #endregion
   
       #region   约束的组合使用
       class Test7<T> where T: class,new()
       {
       }
       #endregion
   
       #region   多个泛型有约束
       class Test8<T,K> where T:class,new() where K:struct
       {
       }
       #endregion
   
       #region 总结
       //泛型约束：让类型有一定限制
       //class
       //struct
       //new()
       //类名
       //接口名
       //另一个泛型字母
   
       //注意：
       //1.可以组合使用
       //2.多个泛型约束 用where连接即可
       #endregion
   ```
7. ### List

   ```
    #region  List的本质
               //List是一个C#为我们封装好的类，
               //它的本质是一个可变类型的泛型数组，
               //List类帮助我们实现了很多方法，
               //比如泛型数组的增删查改
               #endregion
   
               #region   申明
               //需要引用命名空间
               //using System.Collections.Generic
               List<int> list = new List<int>();
               List<string> list2 = new List<string>();
               List<bool> list3 = new List<bool>();
               #endregion
   
               #region 增删查改
   
               #region 增
               list.Add(1);
               list.Add(2);
               list.Add(3);
               list.Add(4);
   
               list2.Add("123");
   
               List<string> listStr = new List<string>();
               listStr.Add("123");
               list2.AddRange(listStr);
   
               list.Insert(0, 999);
               Console.WriteLine(list[0]);
               #endregion
   
               #region 删
               //1.移除指定元素
               list.Remove(1);
               //2.移除指定位置的元素
               list.RemoveAt(0);
               //3.清空
               list.Clear();
   
               list.Add(1);
               list.Add(2);
               list.Add(3);
               list.Add(4);
               list.Add(1);
               #endregion
   
               #region 查
               //1.得到指定位置的元素
               Console.WriteLine(list[0]);
               //2.查看元素是否存在
               if( list.Contains(1) )
               {
                   Console.WriteLine("存在元素 1");
               }
               //3.正向查找元素位置
               // 找到返回位置 找不到 返回-1
               int index = list.IndexOf(5);
               Console.WriteLine(index);
               //4.反向查找元素位置
               // 找到返回位置 找不到 返回-1
               index = list.LastIndexOf(2);
               Console.WriteLine(index);
               #endregion
   
               #region 改
               Console.WriteLine(list[0]);
               list[0] = 99;
               Console.WriteLine(list[0]);
               #endregion
   
               #endregion
   
               #region  遍历
               //长度
               Console.WriteLine(list.Count);
               //容量
               //避免产生垃圾
               Console.WriteLine(list.Capacity);
               Console.WriteLine("**********************");
               for (int i = 0; i < list.Count; i++)
               {
                   Console.WriteLine(list[i]);
               }
               Console.WriteLine("**********************");
               foreach (int item in list)
               {
                   Console.WriteLine(item);
               }
   
               #endregion
   ```
8. ### Dictionary

   ```
   #region Dictionary的本质
               //可以将Dictionary理解为 拥有泛型的Hashtable
               //它也是基于键的哈希代码组织起来的 键/值对
               //键值对类型从Hashtable的object变为了可以自己制定的泛型
               #endregion
   
               #region   申明
               //需要引用命名空间 using System.Collections.Generic
               Dictionary<int, string> dictionary = new Dictionary<int, string>();
               #endregion
   
               #region  增删查改
   
               #region 增
               //注意：不能出现相同键
               dictionary.Add(1, "123");
               dictionary.Add(2, "222");
               dictionary.Add(3, "222");
               //dictionary.Add(3, "123");
               #endregion
   
               #region 删
               //1.只能通过键去删除
               //  删除不存在键 没反应
               dictionary.Remove(1);
               dictionary.Remove(4);
   
               //2.清空
               dictionary.Clear();
               dictionary.Add(1, "123");
               dictionary.Add(2, "222");
               dictionary.Add(3, "222");
               #endregion
   
               #region 查
               //1.通过键查看值
               //  找不到直接报错
               Console.WriteLine(dictionary[2]);
               //Console.WriteLine(dictionary[4]);
               Console.WriteLine(dictionary[1]);
   
               //2.查看是否存在
               //  根据键检测
               if( dictionary.ContainsKey(4) )
               {
                   Console.WriteLine("存在键为1的键值对");
               }
               //  根据值检测
               if (dictionary.ContainsValue("1234"))
               {
                   Console.WriteLine("存在值为123的键值对");
               }
   
               #endregion
   
               #region 改
               Console.WriteLine(dictionary[1]);
               dictionary[1] = "555";
               Console.WriteLine(dictionary[1]);
               #endregion
   
               #endregion
   
               #region   遍历
               Console.WriteLine("**************");
               Console.WriteLine(dictionary.Count);
               //1.遍历所有键
               foreach (int item in dictionary.Keys)
               {
                   Console.WriteLine(item);
                   Console.WriteLine(dictionary[item]);
               }
               //2.遍历所有值
               Console.WriteLine("**************");
               foreach (string item in dictionary.Values)
               {
                   Console.WriteLine(item);
               }
               //3.键值对一起遍历
               Console.WriteLine("**************");
               foreach (KeyValuePair<int,string> item in dictionary)
               {
                   Console.WriteLine("键：" + item.Key + "值：" + item.Value);
               }
               #endregion
   ```
9. ###  顺序存储 和 链式存储

   ```
    #region 顺序存储
               //数组、Stack、Queue、List、ArrayList —— 顺序存储
               //只是 数组、Stack、Queue的 组织规则不同而已
               //顺序存储：
               //用一组地址连续的存储单元依次存储线性表的各个数据元素
               #endregion
   
               #region 链式存储
               //单向链表、双向链表、循环链表 —— 链式存储
               //链式存储(链接存储)：
               //用一组任意的存储单元存储线性表中的各个数据元素
               #endregion
               
                   #region   实现一个最简单的单向链表
       /// <summary>
       /// 单向链表节点
       /// </summary>
       /// <typeparam name="T"></typeparam>
       class LinkedNode<T>
       {
           public T value;
           //这个存储下一个元素是谁 相当于钩子
           public LinkedNode<T> nextNode;
   
           public LinkedNode(T value)
           {
               this.value = value;
           }
       }
   
       /// <summary>
       /// 单向链表类 管理 节点 管理 添加等等
       /// </summary>
       /// <typeparam name="T"></typeparam>
       class LindedList<T>
       {
           public LinkedNode<T> head;
           public LinkedNode<T> last;
   
           public void Add(T value)
           {
               //添加节点 必然是new一个新的节点
               LinkedNode<T> node = new LinkedNode<T>(value);
               if( head == null )
               {
                   head = node;
                   last = node;
               }
               else
               {
                   last.nextNode = node;
                   last = node;
               }
           }
   
           public void Remove(T value)
           {
               if( head == null )
               {
                   return;
               }
               if( head.value.Equals(value) )
               {
                   head = head.nextNode;
                   //如果头节点 被移除 发现头节点变空
                   //证明只有一个节点 那尾也要清空
                   if( head == null )
                   {
                       last = null;
                   }
                   return;
               }
               LinkedNode<T> node = head;
               while(node.nextNode != null)
               {
                   if( node.nextNode.value.Equals(value) )
                   {
                       //让当前找到的这个元素的 上一个节点
                       //指向 自己的下一个节点
                       node.nextNode = node.nextNode.nextNode;
                       break;
                   }
               }
           }
       }
       #endregion
   
       #region   顺序存储和链式存储的优缺点
       //从增删查改的角度去思考
       //增：链式存储 计算上 优于顺序存储 （中间插入时链式不用像顺序一样去移动位置）
       //删：链式存储 计算上 优于顺序存储 （中间删除时链式不用像顺序一样去移动位置）
       //查：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）
       //改：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）
       #endregion
   ```
10. ###  LinkedList

    ```
      #region   LinkedList
                //LinkedList是一个C#为我们封装好的类
                //它的本质是一个可变类型的泛型双向链表
                #endregion
    
                #region   申明
                //需要引用命名空间
                //using System.Collections.Generic
                LinkedList<int> linkedList = new LinkedList<int>();
                LinkedList<string> linkedList2 = new LinkedList<string>();
                //链表对象 需要掌握两个类
                //一个是链表本身 一个是链表节点类LinkedListNode
                #endregion
    
                #region  增删查改
    
                #region 增
                //1.在链表尾部添加元素
                linkedList.AddLast(10);
    
                //2.在链表头部添加元素
                linkedList.AddFirst(20);
    
                //3.在某一个节点之后添加一个节点
                //  要指定节点 先得得到一个节点
                LinkedListNode<int> n = linkedList.Find(20);
                linkedList.AddAfter(n, 15);
                //4.在某一个节点之前添加一个节点
                //  要指定节点 先得得到一个节点
                linkedList.AddBefore(n, 11);
                #endregion
    
                #region 删
                //1.移除头节点
                linkedList.RemoveFirst();
                //2.移除尾节点
                linkedList.RemoveLast();
                //3.移除指定节点
                //  无法通过位置直接移除
                linkedList.Remove(20);
                //4.清空
                linkedList.Clear();
    
                linkedList.AddLast(1);
                linkedList.AddLast(2);
                linkedList.AddLast(3);
                linkedList.AddLast(4);
                #endregion
    
                #region 查
                //1.头节点
                LinkedListNode<int> first = linkedList.First;
                //2.尾节点
                LinkedListNode<int> last = linkedList.Last;
                //3.找到指定值的节点
                //  无法直接通过下标获取中间元素
                //  只有遍历查找指定位置元素
                LinkedListNode<int> node = linkedList.Find(3);
                Console.WriteLine(node.Value);
                node = linkedList.Find(5);
                //4.判断是否存在
                if( linkedList.Contains(1) )
                {
                    Console.WriteLine("链表中存在1");
                }
                #endregion
    
                #region 改
                //要先得再改 得到节点 再改变其中的值
                Console.WriteLine(linkedList.First.Value);
                linkedList.First.Value = 10;
                Console.WriteLine(linkedList.First.Value);
                #endregion
    
                #endregion
    
                #region   遍历
                //1.foreach遍历
                foreach (int item in linkedList)
                {
                    Console.WriteLine(item);
                }
    
                //2.通过节点遍历
                //  从头到尾
                Console.WriteLine("&&&&&&&&&&&&&&&&&&&&&&&&&&&");
                LinkedListNode<int> nowNode = linkedList.First;
                while (nowNode != null)
                {
                    Console.WriteLine(nowNode.Value);
                    nowNode = nowNode.Next;
                }
    
                //  从尾到头
    
                Console.WriteLine("&&&&&&&&&&&&&&&&&&&&&&&&&&&");
                nowNode = linkedList.Last;
                while (nowNode != null)
                {
                    Console.WriteLine(nowNode.Value);
                    nowNode = nowNode.Previous;
                }
    
                #endregion
    ```
11. ### 泛型栈 和 队列

    ```
       #region 泛型数据集合
                //using System.Collections.Generic;
    
                //List  列表  泛型列表
                //Dictionary 字典  泛型哈希表
                //LinkedList 双向链表 
                //Statck 泛型栈
                //Queue 泛型队列
                #endregion
    
                #endregion
    
                #region   泛型栈和队列
                //命名空间：using System.Collections.Generic;
                //使用上 和之前的Stack和Queue一模一样
                Stack<int> stack = new Stack<int>();
                Queue<object> queue = new Queue<object>();
                #endregion
    ```
12. ### 委托

    ```
    using System;
    namespace Lesson12_委托
    {
        #region   委托是什么
        //委托是 函数(方法)的容器 
        //可以理解为表示函数(方法)的变量类型
        //用来 存储、传递函数(方法)
        //委托的本质是一个类，用来定义函数(方法)的类型（返回值和参数的类型）
        //不同的 函数(方法)必须对应和各自"格式"一致的委托
        #endregion
        #region   基本语法
        //关键字 ： delegate
        //语法：访问修饰符 delegate 返回值 委托名(参数列表);
        //写在哪里？
        //可以申明在namespace和class语句块中
        //更多的写在namespace中
        //简单记忆委托语法 就是 函数申明语法前面加一个delegate关键字
        #endregion
        #region   定义自定义委托
        //访问修饰默认不写 为public 在别的命名空间中也能使用
        //private 其它命名空间就不能用了
        //一般使用public
        //申明了一个可以用来存储无参无返回值函数的容器
        //这里只是定义了规则 并没有使用
        delegate void MyFun();
        //委托规则的申明 是不能重名（同一语句块中）
        //表示用来装载或传递 返回值为int 有一个int参数的函数的 委托 容器规则
        public delegate int MyFun2(int a);
        //委托是支持 泛型的 可以让返回值和参数 可变 更方便我们的使用
        delegate T MyFun3<T, K>(T v, K k);
        #endregion
        #region   使用定义好的委托
        //委托变量是函数的容器
        //委托常用在：
        //1.作为类的成员
        //2.作为函数的参数
        class Test
        {
            public MyFun fun;
            public MyFun2 fun2;
            public Action action;
            public void TestFun( MyFun fun, MyFun2 fun2 )
            {
                //先处理一些别的逻辑 当这些逻辑处理完了 再执行传入的函数
                int i = 1;
                i *= 2;
                i += 2;
                //fun();
                //fun2(i);
                //this.fun = fun;
                //this.fun2 = fun2;
            }
            #region 增 委托变量可以存储多个函数(多播委托)
            public void AddFun(MyFun fun, MyFun2 fun2)
            {
                this.fun += fun;
                this.fun2 += fun2;
            }
            #endregion
            #region 删
            public void RemoveFun(MyFun fun, MyFun2 fun2)
            {
                //this.fun = this.fun - fun;
                this.fun -= fun;
                this.fun2 -= fun2;
            }
            #endregion
        }
        #endregion
        ------------------
                Console.WriteLine("委托");
                //专门用来装载 函数的 容器
                MyFun f = new MyFun(Fun);
                Console.WriteLine("1");
                Console.WriteLine("2");
                Console.WriteLine("3");
                Console.WriteLine("4");
                Console.WriteLine("5");
                f.Invoke();
    
                MyFun f2 = Fun;
                f2();
                MyFun2 f3 = Fun2;
                Console.WriteLine(f3(1));
                MyFun2 f4 = new MyFun2(Fun2);
                Console.WriteLine(f4.Invoke(3));
                Test t = new Test();
                t.TestFun(Fun, Fun2);
                Console.WriteLine("***************");
                //如何用委托存储多个函数
                MyFun ff = null;
                //ff = ff + Fun;
                ff += Fun;
                ff += Fun3;
                ff();
                //从容器中移除指定的函数
                ff -= Fun;
                //多减 不会报错 无非就是不处理而已
                ff -= Fun;
                ff();
                //清空容器
                ff = null;
                if( ff != null )
                {
                    ff();
                }
                #region 知识点六 系统定义好的委托
                //使用系统自带委托 需要引用using System;
                //无参无返回值
                Action action = Fun;
                action += Fun3;
                action();
                //可以指定返回值类型的 泛型委托
                Func<string> funcString = Fun4;
                Func<int> funcInt = Fun5;
                //可以传n个参数的  系统提供了 1到16个参数的委托 直接用就行了
                Action<int, string> action2 = Fun6;
                //可以穿n个参数的 并且有返回值的 系统也提供了 16个委托
                Func<int, int> func2 = Fun2;
                #endregion
            }
    
            static void Fun(){}
            static void Fun3(){}
            static string Fun4(){}
            static int Fun5(){}
            static void Fun6(int i, string s){}
    		static int Fun2(int value){}
        }
    
        //总结
        //简单理解 委托 就是装载、传递函数的容器而已
        //可以用委托变量 来存储函数或者传递函数的
        //系统其实已经提供了很多委托给我们用 
        //Action:没有返回值，参数提供了 0~16个委托给我们用
        //Func:有返回值，参数提供了 0~16个委托给我们用
    }
    
    ```